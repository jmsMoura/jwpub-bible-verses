/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  VERSION: () => VERSION,
  default: () => JWPubPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  language: "E",
  // Default to English
  autoUpdate: true,
  updateInterval: 14,
  // days
  insertLinkOnly: false,
  // Default to inserting verses
  linkPrefix: "",
  linkSuffix: "",
  versePrefix: "",
  verseSuffix: "",
  customBookNames: {},
  standardAbbreviations: {},
  alternateAbbreviations: {},
  localizedBookNames: {},
  lastLanguageUpdate: {}
};
var VERSION = "1.1.8";
var BibleService = class {
  constructor(settings) {
    /**
     * Store standard abbreviations for books
     */
    this.standardAbbreviations = {};
    /**
     * Store alternate abbreviations for books
     */
    this.alternateAbbreviations = {};
    /**
     * Store original capitalization of full names from JW.org
     */
    this.originalFullNames = {};
    /**
     * Store original capitalization of long abbreviations from JW.org
     */
    this.originalLongAbbrs = {};
    /**
     * Store original capitalization of short abbreviations from JW.org
     */
    this.originalShortAbbrs = {};
    this.settings = settings;
  }
  /**
   * Parse a Bible reference string into a standardized format for JW.org URLs.
   * @param reference The Bible reference (e.g., "John 3:16", "1 Peter 5:7")
   * @returns URL-friendly Bible reference code like "40001001" for Matthews 1:1
   */
  parseReference(reference) {
    const bibleBooks = {
      // Old Testament
      "genesis": 1,
      "gen": 1,
      "gn": 1,
      "exodus": 2,
      "exod": 2,
      "ex": 2,
      "leviticus": 3,
      "lev": 3,
      "lv": 3,
      "numbers": 4,
      "num": 4,
      "nm": 4,
      "nb": 4,
      "deuteronomy": 5,
      "deut": 5,
      "dt": 5,
      "joshua": 6,
      "josh": 6,
      "jos": 6,
      "judges": 7,
      "judg": 7,
      "jdg": 7,
      "ruth": 8,
      "ru": 8,
      "rt": 8,
      "1 samuel": 9,
      "1samuel": 9,
      "1 sam": 9,
      "1sam": 9,
      "1 sa": 9,
      "1sa": 9,
      "2 samuel": 10,
      "2samuel": 10,
      "2 sam": 10,
      "2sam": 10,
      "2 sa": 10,
      "2sa": 10,
      "1 kings": 11,
      "1kings": 11,
      "1 kgs": 11,
      "1kgs": 11,
      "1 ki": 11,
      "1ki": 11,
      "2 kings": 12,
      "2kings": 12,
      "2 kgs": 12,
      "2kgs": 12,
      "2 ki": 12,
      "2ki": 12,
      "1 chronicles": 13,
      "1chronicles": 13,
      "1 chron": 13,
      "1chron": 13,
      "1 chr": 13,
      "1chr": 13,
      "2 chronicles": 14,
      "2chronicles": 14,
      "2 chron": 14,
      "2chron": 14,
      "2 chr": 14,
      "2chr": 14,
      "ezra": 15,
      "ezr": 15,
      "ez": 15,
      "nehemiah": 16,
      "neh": 16,
      "ne": 16,
      "esther": 17,
      "est": 17,
      "es": 17,
      "job": 18,
      "jb": 18,
      "psalms": 19,
      "psalm": 19,
      "ps": 19,
      "psa": 19,
      "psm": 19,
      "proverbs": 20,
      "prov": 20,
      "pr": 20,
      "prv": 20,
      "ecclesiastes": 21,
      "eccl": 21,
      "ec": 21,
      "qoh": 21,
      "song of solomon": 22,
      "song of songs": 22,
      "song": 22,
      "songs": 22,
      "song of sol": 22,
      "sos": 22,
      "ss": 22,
      "canticle of canticles": 22,
      "isaiah": 23,
      "isa": 23,
      "is": 23,
      "jeremiah": 24,
      "jer": 24,
      "je": 24,
      "lamentations": 25,
      "lam": 25,
      "la": 25,
      "ezekiel": 26,
      "ezek": 26,
      "eze": 26,
      "ezk": 26,
      "daniel": 27,
      "dan": 27,
      "da": 27,
      "dn": 27,
      "hosea": 28,
      "hos": 28,
      "ho": 28,
      "joel": 29,
      "jl": 29,
      "amos": 30,
      "am": 30,
      "obadiah": 31,
      "obad": 31,
      "ob": 31,
      "jonah": 32,
      "jon": 32,
      "jnh": 32,
      "micah": 33,
      "mic": 33,
      "mi": 33,
      "nahum": 34,
      "nah": 34,
      "na": 34,
      "habakkuk": 35,
      "hab": 35,
      "hb": 35,
      "zephaniah": 36,
      "zeph": 36,
      "zep": 36,
      "zp": 36,
      "haggai": 37,
      "hag": 37,
      "hg": 37,
      "zechariah": 38,
      "zech": 38,
      "zec": 38,
      "zc": 38,
      "malachi": 39,
      "mal": 39,
      "ml": 39,
      // New Testament
      "matthew": 40,
      "matthews": 40,
      "matt": 40,
      "mat": 40,
      "mt": 40,
      "mark": 41,
      "mrk": 41,
      "mk": 41,
      "mr": 41,
      "luke": 42,
      "luk": 42,
      "lk": 42,
      "lu": 42,
      "john": 43,
      "joh": 43,
      "jhn": 43,
      "jn": 43,
      "acts": 44,
      "act": 44,
      "ac": 44,
      "acts of the apostles": 44,
      "romans": 45,
      "rom": 45,
      "ro": 45,
      "rm": 45,
      "1 corinthians": 46,
      "1corinthians": 46,
      "1 cor": 46,
      "1cor": 46,
      "1 co": 46,
      "1co": 46,
      "2 corinthians": 47,
      "2corinthians": 47,
      "2 cor": 47,
      "2cor": 47,
      "2 co": 47,
      "2co": 47,
      "galatians": 48,
      "gal": 48,
      "ga": 48,
      "ephesians": 49,
      "eph": 49,
      "ep": 49,
      "philippians": 50,
      "phil": 50,
      "php": 50,
      "pp": 50,
      "colossians": 51,
      "col": 51,
      "co": 51,
      "1 thessalonians": 52,
      "1thessalonians": 52,
      "1 thess": 52,
      "1thess": 52,
      "1 thes": 52,
      "1thes": 52,
      "1 th": 52,
      "1th": 52,
      "2 thessalonians": 53,
      "2thessalonians": 53,
      "2 thess": 53,
      "2thess": 53,
      "2 thes": 53,
      "2thes": 53,
      "2 th": 53,
      "2th": 53,
      "1 timothy": 54,
      "1timothy": 54,
      "1 tim": 54,
      "1tim": 54,
      "1 ti": 54,
      "1ti": 54,
      "2 timothy": 55,
      "2timothy": 55,
      "2 tim": 55,
      "2tim": 55,
      "2 ti": 55,
      "2ti": 55,
      "titus": 56,
      "tit": 56,
      "ti": 56,
      "philemon": 57,
      "philem": 57,
      "phm": 57,
      "pm": 57,
      "hebrews": 58,
      "heb": 58,
      "he": 58,
      "james": 59,
      "jas": 59,
      "jm": 59,
      "ja": 59,
      "1 peter": 60,
      "1peter": 60,
      "1 pet": 60,
      "1pet": 60,
      "1 pe": 60,
      "1pe": 60,
      "1 pt": 60,
      "1pt": 60,
      "2 peter": 61,
      "2peter": 61,
      "2 pet": 61,
      "2pet": 61,
      "2 pe": 61,
      "2pe": 61,
      "2 pt": 61,
      "2pt": 61,
      "1 john": 62,
      "1john": 62,
      "1 jn": 62,
      "1jn": 62,
      "1 jo": 62,
      "1jo": 62,
      "2 john": 63,
      "2john": 63,
      "2 jn": 63,
      "2jn": 63,
      "2 jo": 63,
      "2jo": 63,
      "3 john": 64,
      "3john": 64,
      "3 jn": 64,
      "3jn": 64,
      "3 jo": 64,
      "3jo": 64,
      "jude": 65,
      "jud": 65,
      "jd": 65,
      "revelation": 66,
      "rev": 66,
      "re": 66,
      "rv": 66,
      "apocalypse": 66
    };
    const bookNameSources = [
      {},
      // Custom book names - will be filled if available
      {},
      // Full book names - will be filled if available
      {},
      // Localized book names - will be filled if available
      {},
      // Standard abbreviations - will be filled if available
      {}
      // Alternate abbreviations - will be filled if available
    ];
    if (this.settings.customBookNames) {
      for (let i = 1; i <= 66; i++) {
        const bookCode = i.toString().padStart(2, "0");
        if (this.settings.customBookNames[bookCode]) {
          const customName = this.settings.customBookNames[bookCode].toLowerCase();
          bookNameSources[0][customName] = i;
        }
      }
    }
    for (let i = 1; i <= 66; i++) {
      const fullName = this.getOriginalFullName(i);
      if (fullName) {
        bookNameSources[1][fullName.toLowerCase()] = i;
      }
    }
    if (this.settings.localizedBookNames && this.settings.localizedBookNames[this.settings.language]) {
      Object.entries(this.settings.localizedBookNames[this.settings.language]).forEach(([name, number]) => {
        bookNameSources[2][name.toLowerCase()] = number;
      });
    }
    if (this.settings.standardAbbreviations) {
      for (let i = 1; i <= 66; i++) {
        const bookCode = i.toString().padStart(2, "0");
        if (this.settings.standardAbbreviations[bookCode]) {
          const stdAbbrev = this.settings.standardAbbreviations[bookCode].toLowerCase();
          bookNameSources[3][stdAbbrev] = i;
        }
      }
    }
    if (this.settings.alternateAbbreviations) {
      for (let i = 1; i <= 66; i++) {
        const bookCode = i.toString().padStart(2, "0");
        if (this.settings.alternateAbbreviations[bookCode]) {
          const altAbbrev = this.settings.alternateAbbreviations[bookCode].toLowerCase();
          bookNameSources[4][altAbbrev] = i;
        }
      }
    }
    const combinedBooks = { ...bibleBooks };
    const normalizedReference = reference.replace(/\./g, "").toLowerCase().trim();
    console.log(`Parsing reference: "${normalizedReference}"`);
    let bookName = "";
    let bookNumber = 0;
    let remainingText = "";
    for (const source of bookNameSources) {
      const sortedBookNames = Object.keys(source).sort((a, b) => b.length - a.length);
      for (const name of sortedBookNames) {
        if (normalizedReference.startsWith(name) && (normalizedReference.length === name.length || !/[a-z]/.test(normalizedReference.charAt(name.length)))) {
          bookName = name;
          bookNumber = source[name];
          remainingText = normalizedReference.substring(name.length).trim();
          break;
        }
      }
      if (bookName && bookNumber) {
        break;
      }
    }
    if (!bookName || !bookNumber) {
      const sortedBookNames = Object.keys(combinedBooks).sort((a, b) => b.length - a.length);
      for (const name of sortedBookNames) {
        if (normalizedReference.startsWith(name) && (normalizedReference.length === name.length || !/[a-z]/.test(normalizedReference.charAt(name.length)))) {
          bookName = name;
          bookNumber = combinedBooks[name];
          remainingText = normalizedReference.substring(name.length).trim();
          break;
        }
      }
    }
    if (!bookName || !bookNumber) {
      console.log(`Could not identify book name in: "${normalizedReference}"`);
      return null;
    }
    console.log(`Identified book: "${bookName}" (${bookNumber}), remaining text: "${remainingText}"`);
    const chapterVerseRegex = /^(\d+):(\d+)(?:[-,](\d+))?/;
    const chapterVerseMatch = remainingText.match(chapterVerseRegex);
    if (!chapterVerseMatch) {
      console.log(`Could not extract chapter and verse from: "${remainingText}"`);
      return null;
    }
    const chapter = chapterVerseMatch[1];
    const verse = chapterVerseMatch[2];
    const endVerse = chapterVerseMatch[3];
    console.log(`Extracted chapter: ${chapter}, verse: ${verse}${endVerse ? `, end verse: ${endVerse}` : ""}`);
    const paddedBookNumber = bookNumber.toString().padStart(2, "0");
    const paddedChapter = chapter.padStart(3, "0");
    const paddedVerse = verse.padStart(3, "0");
    const finalCode = `${paddedBookNumber}${paddedChapter}${paddedVerse}`;
    console.log(`Generated reference code: ${finalCode}`);
    if (endVerse) {
      const paddedEndVerse = endVerse.padStart(3, "0");
      return `${finalCode}-${paddedBookNumber}${paddedChapter}${paddedEndVerse}`;
    }
    return finalCode;
  }
  /**
   * Generate a JW.org URL for a Bible reference
   * @param referenceCode The Bible reference code (e.g., "40001001" for Matthew 1:1)
   * @returns Full JW.org URL to fetch the Bible verse
   */
  generateUrl(referenceCode) {
    const isRange = referenceCode.includes("-");
    if (isRange) {
      const [startCode, endCode] = referenceCode.split("-");
      const bookNumber = parseInt(startCode.substring(0, 2));
      const urlStartCode = bookNumber <= 9 ? `${bookNumber}${startCode.substring(2)}` : startCode;
      const urlEndCode = bookNumber <= 9 ? `${bookNumber}${endCode.substring(2)}` : endCode;
      return `https://www.jw.org/finder?wtlocale=${this.settings.language}&bible=${urlStartCode}-${urlEndCode}`;
    } else {
      const bookNumber = parseInt(referenceCode.substring(0, 2));
      const urlReferenceCode = bookNumber <= 9 ? `${bookNumber}${referenceCode.substring(2)}` : referenceCode;
      return `https://www.jw.org/finder?wtlocale=${this.settings.language}&bible=${urlReferenceCode}`;
    }
  }
  /**
   * Fetch the Bible verse text from JW.org
   * @param referenceCode Bible reference code
   * @returns The verse text or null if not found
   */
  async fetchVerse(referenceCode) {
    try {
      const isRange = referenceCode.includes("-");
      let bookNumber, chapter, verse, endVerse, book, formattedReference;
      if (isRange) {
        const [startCode, endCode] = referenceCode.split("-");
        bookNumber = parseInt(startCode.substring(0, 2));
        chapter = parseInt(startCode.substring(2, 5)).toString();
        verse = parseInt(startCode.substring(5, 8)).toString();
        endVerse = parseInt(endCode.substring(5, 8)).toString();
        book = this.getBookNameFromCode(bookNumber.toString().padStart(2, "0"));
        formattedReference = `${book} ${chapter}:${verse}-${endVerse}`;
        console.log(`Fetching verse range: ${formattedReference} with code ${referenceCode}`);
      } else {
        bookNumber = parseInt(referenceCode.substring(0, 2));
        chapter = parseInt(referenceCode.substring(2, 5)).toString();
        verse = parseInt(referenceCode.substring(5, 8)).toString();
        book = this.getBookNameFromCode(bookNumber.toString().padStart(2, "0"));
        formattedReference = `${book} ${chapter}:${verse}`;
        console.log(`Fetching verse: ${formattedReference} with code ${referenceCode}`);
      }
      const finderUrl = this.generateUrl(referenceCode);
      console.log(`Using URL: ${finderUrl}`);
      try {
        const response = await (0, import_obsidian.requestUrl)({
          url: finderUrl,
          method: "GET",
          headers: {
            "Accept": "text/html",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
          }
        });
        const originalUrl = finderUrl;
        const redirectedPattern = response.text.includes("Found. Redirecting to");
        if (redirectedPattern) {
          console.log(`Response contains redirect information`);
        }
        const html = response.text;
        console.log(`Received HTML response, length: ${html.length}`);
        let redirectUrl = null;
        const redirectMatch = html.match(/Found\.\s*Redirecting to\s*(https:\/\/[^"'\s]+)/i);
        if (redirectMatch && redirectMatch[1]) {
          redirectUrl = redirectMatch[1];
          console.log(`Detected redirect to: ${redirectUrl}`);
          try {
            const redirectResponse = await (0, import_obsidian.requestUrl)({
              url: redirectUrl,
              method: "GET",
              headers: {
                "Accept": "text/html",
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
              }
            });
            const redirectHtml = redirectResponse.text;
            console.log(`Received redirected HTML, length: ${redirectHtml.length}`);
            if (isRange && endVerse) {
              return this.extractVerseRangeFromHtml(redirectHtml, referenceCode, formattedReference, bookNumber, verse, endVerse);
            } else {
              return this.extractVerseFromHtml(redirectHtml, referenceCode, formattedReference, bookNumber, verse);
            }
          } catch (error) {
            console.error(`Error following redirect: ${error}`);
          }
        }
        if (isRange && endVerse) {
          return this.extractVerseRangeFromHtml(html, referenceCode, formattedReference, bookNumber, verse, endVerse);
        } else {
          return this.extractVerseFromHtml(html, referenceCode, formattedReference, bookNumber, verse);
        }
      } catch (error) {
        console.error(`Error accessing URL: ${error}`);
        return {
          text: "Error fetching verse. Please check your connection and try again.",
          reference: formattedReference
        };
      }
    } catch (error) {
      console.error(`Error in fetchVerse: ${error}`);
      return null;
    }
  }
  /**
   * Extract a range of verses from HTML content
   * @param html HTML content to extract verses from
   * @param referenceCode Bible reference code
   * @param formattedReference Formatted reference string
   * @param bookNumber Bible book number
   * @param startVerse Starting verse number
   * @param endVerse Ending verse number
   * @returns Extracted verses or error message
   */
  extractVerseRangeFromHtml(html, referenceCode, formattedReference, bookNumber, startVerse, endVerse) {
    try {
      console.log(`Extracting verse range: ${formattedReference} (${startVerse}-${endVerse})`);
      const chapter = referenceCode.split("-")[0].substring(2, 5);
      const verses = [];
      const isSingleVerse = startVerse === endVerse;
      const isPsalmsVerse = bookNumber === 19;
      for (let verseNum = parseInt(startVerse); verseNum <= parseInt(endVerse); verseNum++) {
        const paddedVerse = verseNum.toString().padStart(3, "0");
        const verseReferenceCode = `${referenceCode.split("-")[0].substring(0, 5)}${paddedVerse}`;
        const htmlVerseId = `v${verseReferenceCode}`;
        console.log(`Looking for verse ID: ${htmlVerseId}`);
        const verseStartPattern = new RegExp(`<span class="verse" id="${htmlVerseId}">`);
        const verseStartMatch = html.match(verseStartPattern);
        if (verseStartMatch && verseStartMatch.index !== void 0) {
          const nextVersePattern = /<span class="verse" id="v[0-9]+"|<div class="chapterContent/;
          const remainingHtml = html.substring(verseStartMatch.index + verseStartMatch[0].length);
          const nextVerseMatch = remainingHtml.match(nextVersePattern);
          let verseHtml;
          if (nextVerseMatch && nextVerseMatch.index !== void 0) {
            verseHtml = remainingHtml.substring(0, nextVerseMatch.index);
          } else {
            verseHtml = remainingHtml;
          }
          let cleanedText = isPsalmsVerse ? this.cleanPsalmsText(verseHtml) : this.cleanHtmlFragment(verseHtml);
          if (cleanedText.trim()) {
            if (isSingleVerse || parseInt(startVerse) === parseInt(endVerse)) {
              verses.push(cleanedText.trim().replace(/^\d+\s+/, ""));
            } else {
              const verseNumPattern = new RegExp(`^${verseNum}\\s+`);
              if (verseNumPattern.test(cleanedText.trim())) {
                verses.push(cleanedText.trim().replace(
                  new RegExp(`^${verseNum}\\s+`),
                  `\`${verseNum}\` `
                ));
              } else {
                verses.push(`\`${verseNum}\` ${cleanedText.trim()}`);
              }
            }
            console.log(`Found verse ${verseNum}: ${cleanedText.substring(0, 50)}...`);
          }
        } else {
          console.log(`Could not find verse ID ${htmlVerseId} in HTML`);
          const singleVerseResult = this.extractVerseFromHtml(
            html,
            verseReferenceCode,
            `${formattedReference.split(":")[0]}:${verseNum}`,
            bookNumber,
            verseNum.toString()
          );
          if (singleVerseResult && !singleVerseResult.text.includes("Could not extract verse content")) {
            let extractedText = singleVerseResult.text;
            if (isSingleVerse || parseInt(startVerse) === parseInt(endVerse)) {
              verses.push(extractedText.replace(/^\d+\s+/, ""));
            } else {
              const verseNumPattern = new RegExp(`^${verseNum}\\s+`);
              if (verseNumPattern.test(extractedText)) {
                verses.push(extractedText.replace(
                  new RegExp(`^${verseNum}\\s+`),
                  `\`${verseNum}\` `
                ));
              } else {
                verses.push(`\`${verseNum}\` ${extractedText}`);
              }
            }
            console.log(`Found verse ${verseNum} using single verse extraction`);
          }
        }
      }
      if (verses.length === 0) {
        console.log("Trying alternative method for extracting verse range");
        const chapterContentPattern = /<article[^>]*?class="[^"]*?bibleCitation[^"]*?"[^>]*?>([\s\S]*?)<\/article>/i;
        const chapterMatch = html.match(chapterContentPattern);
        if (chapterMatch && chapterMatch[1]) {
          const chapterHtml = chapterMatch[1];
          for (let verseNum = parseInt(startVerse); verseNum <= parseInt(endVerse); verseNum++) {
            const paddedVerse = verseNum.toString().padStart(3, "0");
            const verseReferenceCode = `${referenceCode.split("-")[0].substring(0, 5)}${paddedVerse}`;
            const htmlVerseId = `v${verseReferenceCode}`;
            const versePattern = new RegExp(`<span[^>]*?class="verse"[^>]*?id="${htmlVerseId}"[^>]*?>(.*?)</span>\\s*(?:<span class="verse"|</div>)`, "s");
            const verseMatch = chapterHtml.match(versePattern);
            if (verseMatch && verseMatch[1]) {
              const verseText = isPsalmsVerse ? this.cleanPsalmsText(verseMatch[1]) : this.cleanHtmlFragment(verseMatch[1]);
              if (verseText.trim()) {
                if (isSingleVerse || parseInt(startVerse) === parseInt(endVerse)) {
                  verses.push(verseText.trim().replace(/^\d+\s+/, ""));
                } else {
                  const verseNumPattern = new RegExp(`^${verseNum}\\s+`);
                  if (verseNumPattern.test(verseText.trim())) {
                    verses.push(verseText.trim().replace(
                      new RegExp(`^${verseNum}\\s+`),
                      `\`${verseNum}\` `
                    ));
                  } else {
                    verses.push(`\`${verseNum}\` ${verseText.trim()}`);
                  }
                }
                console.log(`Found verse ${verseNum} in chapter content`);
              }
            }
          }
        }
      }
      let combinedText = verses.join(" ");
      combinedText = combinedText.replace(/([.,:;!?])([A-ZÀ-ÚÄ-Ü])/g, "$1 $2").replace(/([a-záàâãéèêíïóôõöúçñ])([A-ZÀ-ÚÄ-Ü])/g, "$1 $2");
      if (!combinedText) {
        console.error(`Could not extract verse range ${startVerse}-${endVerse}`);
        return {
          text: `Could not extract verse range ${startVerse}-${endVerse}`,
          reference: formattedReference
        };
      }
      return {
        text: combinedText,
        reference: formattedReference
      };
    } catch (error) {
      console.error(`Error extracting verse range:`, error);
      return {
        text: `Error extracting verse range: ${error}`,
        reference: formattedReference
      };
    }
  }
  /**
   * Extract verse text from HTML content
   * @param html HTML content to extract verse from
   * @param referenceCode Bible reference code
   * @param formattedReference Formatted reference string
   * @param bookNumber Bible book number
   * @param verse Verse number
   * @returns Extracted verse or error message
   */
  extractVerseFromHtml(html, referenceCode, formattedReference, bookNumber, verse) {
    const isHebrewScripture = bookNumber >= 1 && bookNumber <= 39;
    const isGreekScripture = bookNumber >= 40 && bookNumber <= 66;
    const isFirstVerseInChapter = verse === "1";
    const chapter = referenceCode.substring(2, 5);
    const htmlVerseId = `v${referenceCode}`;
    console.log(`Extracting verse with HTML ID: ${htmlVerseId}, IsHebrewScripture: ${isHebrewScripture}`);
    let extractedText = "";
    if (!extractedText) {
      console.log("Strategy 1: Checking for paragraph breaks");
      try {
        const mainVersePattern = new RegExp(`<span class="verse" id="${htmlVerseId}">([\\s\\S]*?)(?:</span>\\s*<span class="parabreak">|</span>\\s*</span>)`, "s");
        const mainVerseMatch = html.match(mainVersePattern);
        if (mainVerseMatch && mainVerseMatch[1]) {
          const textParts = [];
          const styleRegex = /<span class="style-[a-z]">([^<]+)<\/span>/g;
          let styleMatch;
          while ((styleMatch = styleRegex.exec(mainVerseMatch[1])) !== null) {
            if (styleMatch[1]) {
              textParts.push(styleMatch[1]);
            }
          }
          if (textParts.length === 0) {
            const cleanedText = this.cleanHtmlFragment(mainVerseMatch[1]);
            if (cleanedText.trim()) {
              textParts.push(cleanedText.trim());
            }
          }
          extractedText = textParts.join(" ");
          console.log(`Parabreak handling found: ${extractedText.substring(0, 50)}...`);
          if (bookNumber === 43 && chapter === "001" && (verse === "1" || verse === "2")) {
            const englishPhraseIndex = extractedText.indexOf("What has come into existence");
            const portuguesePhraseIndex = extractedText.indexOf("O que veio a existir");
            if (englishPhraseIndex !== -1) {
              extractedText = extractedText.substring(0, englishPhraseIndex).trim();
              console.log(`Fixed John 1:${verse} by removing verse 3 content (English)`);
            } else if (portuguesePhraseIndex !== -1) {
              extractedText = extractedText.substring(0, portuguesePhraseIndex).trim();
              console.log(`Fixed Jo\xE3o 1:${verse} by removing verse 3 content (Portuguese)`);
            }
          }
        }
      } catch (e) {
        console.error("Error in paragraph break handling:", e);
      }
    }
    if (!extractedText && isFirstVerseInChapter && isHebrewScripture) {
      console.log("Strategy 2: Hebrew Scripture first verse specific handling");
      try {
        const hebrewFirstVersePatterns = [
          // Pattern 1: Most common Hebrew Scripture first verse pattern
          new RegExp(`<span class="verse" id="${htmlVerseId}"><span class="style-b"><span class="chapterNum"><a[^>]*?>[^<]*?</a></span>([^<]+)`, "s"),
          // Pattern 2: Alternative pattern with whitespace variations
          new RegExp(`<span class="verse" id="${htmlVerseId}">\\s*<span class="style-b">\\s*<span class="chapterNum">.*?</span>\\s*([^<]+)`, "s"),
          // Pattern 3: Broader pattern that captures more context
          new RegExp(`<span class="verse" id="${htmlVerseId}"><span class="style-b"><span class="chapterNum">.*?</span>([\\s\\S]*?)(?:<a class|</span>)`, "s")
        ];
        for (const pattern of hebrewFirstVersePatterns) {
          if (extractedText)
            break;
          const match = html.match(pattern);
          if (match && match[1]) {
            extractedText = this.cleanHtmlFragment(match[1]);
            console.log(`Hebrew Scripture first verse pattern matched: ${extractedText.substring(0, 50)}...`);
            break;
          }
        }
        if (!extractedText) {
          const chapterNumIndex = html.indexOf(`id="${htmlVerseId}"`);
          if (chapterNumIndex > 0) {
            const verseSpanStart = html.substring(chapterNumIndex - 100, chapterNumIndex + 400);
            const chapterEndIndex = verseSpanStart.indexOf("</span>", verseSpanStart.indexOf('<span class="chapterNum">'));
            if (chapterEndIndex > 0) {
              const afterChapterNum = verseSpanStart.substring(chapterEndIndex + 7, chapterEndIndex + 200);
              const endOfVerse = afterChapterNum.indexOf("<");
              if (endOfVerse > 0) {
                const verseText = afterChapterNum.substring(0, endOfVerse).trim();
                if (verseText) {
                  extractedText = verseText;
                  console.log(`Extracted text after chapter number: ${extractedText}`);
                }
              }
            }
          }
        }
      } catch (e) {
        console.error("Error in Hebrew Scripture first verse handling:", e);
      }
    }
    if (!extractedText) {
      console.log("Strategy 3: Matching verse span element with all child content");
      const verseRegex = new RegExp(`<span[^>]*?class="verse"[^>]*?id="${htmlVerseId}"[^>]*?>([\\s\\S]*?)(?:<\\/span>(?:<span class="parabreak"><\\/span>)?<\\/span>|<\\/span>\\s*<span class="verse")`, "s");
      const match = html.match(verseRegex);
      if (match && match[1]) {
        const verseContent = match[1];
        const textFragments = [];
        const styleSpanRegex = /<span class="style-[^"]*?">(.*?)<\/span>/gs;
        let styleMatch;
        let foundStyleSpans = false;
        while ((styleMatch = styleSpanRegex.exec(verseContent)) !== null) {
          foundStyleSpans = true;
          if (styleMatch[1]) {
            const cleanedText = this.cleanHtmlFragment(styleMatch[1]);
            if (cleanedText.trim()) {
              textFragments.push(cleanedText.trim());
            }
          }
        }
        if (foundStyleSpans) {
          console.log(`Found ${textFragments.length} style spans within verse`);
          extractedText = textFragments.join(" ");
        } else {
          extractedText = this.cleanHtmlFragment(verseContent);
        }
        console.log(`Extracted text: ${extractedText.substring(0, 50)}...`);
      }
    }
    if (!extractedText && isFirstVerseInChapter) {
      console.log("Strategy 4: First verse in chapter special handling");
      try {
        const firstVerseRegex = new RegExp(`<span class="verse" id="${htmlVerseId}">([\\s\\S]*?)<\\/span>(?:\\s*<span class="parabreak")|<\\/span>`, "s");
        const firstVerseMatch = html.match(firstVerseRegex);
        if (firstVerseMatch && firstVerseMatch[1]) {
          const styleSpanRegex = /<span class="style-[^"]*?">(.*?)<\/span>/gs;
          let styleMatch;
          const textParts = [];
          while ((styleMatch = styleSpanRegex.exec(firstVerseMatch[1])) !== null) {
            if (styleMatch[1]) {
              const cleanedText = this.cleanHtmlFragment(styleMatch[1]);
              if (cleanedText.trim()) {
                textParts.push(cleanedText.trim());
              }
            }
          }
          if (textParts.length > 0) {
            extractedText = textParts.join(" ");
            console.log(`First verse with style spans: ${extractedText.substring(0, 50)}...`);
          } else {
            extractedText = this.cleanHtmlFragment(firstVerseMatch[1]);
            console.log(`First verse full content: ${extractedText.substring(0, 50)}...`);
          }
        }
      } catch (e) {
        console.error(`Error in first verse special handling: ${e}`);
      }
    }
    if (!extractedText) {
      console.log("Strategy 5: Simple pattern fallback");
      try {
        const simpleVerseRegex = new RegExp(`<span class="verse" id="${htmlVerseId}">(.*?)</span>`, "s");
        const simpleMatch = html.match(simpleVerseRegex);
        if (simpleMatch && simpleMatch[1]) {
          extractedText = this.cleanHtmlFragment(simpleMatch[1]);
          console.log(`Simple pattern match: ${extractedText.substring(0, 50)}...`);
        }
      } catch (e) {
        console.error(`Error in simple pattern fallback: ${e}`);
      }
    }
    if (!extractedText) {
      console.log("Could not extract verse with any strategy");
      return {
        text: `Could not extract verse content. Please click the link to view on jw.org.`,
        reference: formattedReference
      };
    }
    return {
      text: extractedText,
      reference: formattedReference
    };
  }
  /**
   * Clean HTML fragment and ensure proper spacing
   */
  cleanHtmlFragment(html) {
    let plainText = html.replace(/<a[^>]*?class="[^"]*?\b(?:xref|footnote)\b[^"]*?"[^>]*?>([^<]*?)<\/a>/g, "").replace(/<a[^>]*?id="[^"]*?_crossreference[^"]*?"[^>]*?>.*?<\/a>/g, "").replace(/<a[^>]*?id="[^"]*?_footnote[^"]*?"[^>]*?>.*?<\/a>/g, "").replace(/<sup[^>]*?class="[^"]*?footnote[^"]*?"[^>]*?>.*?<\/sup>/g, "").replace(/<span class="lineBreak"><br><\/span>/g, " ").replace(/<[^>]+>/g, " ").replace(/&nbsp;/g, " ").replace(/\s+/g, " ").replace(/([.,:;!?])([A-ZÀ-ÚÄ-Ü])/g, "$1 $2").replace(/([a-záàâãéèêíïóôõöúçñ])([A-ZÀ-ÚÄ-Ü])/g, "$1 $2").replace(/[†‡§¶*]/g, "").replace(/\s([a-z])\s/g, " ").replace(/\s([a-z])(?=[.,;:!?])/g, "").replace(/\s+[eE]\s+/g, " ").replace(/\+/g, "").replace(/\-(?!\w)/g, "").replace(/(?<!\w)\-/g, "").replace(/E(?=\s|$)/g, "").replace(/\s+/g, " ").trim();
    return plainText;
  }
  /**
   * Clean HTML fragments from Psalms/poetry text
   * Special handling for poetic content with line breaks
   */
  cleanPsalmsText(html) {
    let cleanedText = html.replace(/<a[^>]*?class="[^"]*?\b(?:xref|footnote)\b[^"]*?"[^>]*?>([^<]*?)<\/a>/g, "").replace(/<a[^>]*?id="[^"]*?_crossreference[^"]*?"[^>]*?>.*?<\/a>/g, "").replace(/<a[^>]*?id="[^"]*?_footnote[^"]*?"[^>]*?>.*?<\/a>/g, "").replace(/<sup[^>]*?class="[^"]*?footnote[^"]*?"[^>]*?>.*?<\/sup>/g, "").replace(/<span class="lineBreak"><br><\/span>/g, " ").replace(/<[^>]+>/g, " ").replace(/&nbsp;/g, " ").replace(/\s+/g, " ").replace(/([.,:;!?])([A-ZÀ-ÚÄ-Ü])/g, "$1 $2").replace(/([a-záàâãéèêíïóôõöúçñ])([A-ZÀ-ÚÄ-Ü])/g, "$1 $2").replace(/[†‡§¶*]/g, "").replace(/\s([a-z])\s/g, " ").replace(/\s([a-z])(?=[.,;:!?])/g, "").replace(/\s+[eE]\s+/g, " ").replace(/\+/g, "").replace(/\-(?!\w)/g, "").replace(/(?<!\w)\-/g, "").replace(/E(?=\s|$)/g, "").replace(/\s+/g, " ").trim();
    return cleanedText;
  }
  /**
   * Get the book name from a book code
   * @param bookCode Two-digit book code
   * @returns Book name or "Unknown Book"
   */
  getBookNameFromCode(bookCode) {
    const bookNumber = parseInt(bookCode);
    if (this.settings.customBookNames && this.settings.customBookNames[bookCode]) {
      return this.settings.customBookNames[bookCode];
    }
    const books = [
      "Genesis",
      "Exodus",
      "Leviticus",
      "Numbers",
      "Deuteronomy",
      "Joshua",
      "Judges",
      "Ruth",
      "1 Samuel",
      "2 Samuel",
      "1 Kings",
      "2 Kings",
      "1 Chronicles",
      "2 Chronicles",
      "Ezra",
      "Nehemiah",
      "Esther",
      "Job",
      "Psalms",
      "Proverbs",
      "Ecclesiastes",
      "Song of Solomon",
      "Isaiah",
      "Jeremiah",
      "Lamentations",
      "Ezekiel",
      "Daniel",
      "Hosea",
      "Joel",
      "Amos",
      "Obadiah",
      "Jonah",
      "Micah",
      "Nahum",
      "Habakkuk",
      "Zephaniah",
      "Haggai",
      "Zechariah",
      "Malachi",
      "Matthew",
      "Mark",
      "Luke",
      "John",
      "Acts",
      "Romans",
      "1 Corinthians",
      "2 Corinthians",
      "Galatians",
      "Ephesians",
      "Philippians",
      "Colossians",
      "1 Thessalonians",
      "2 Thessalonians",
      "1 Timothy",
      "2 Timothy",
      "Titus",
      "Philemon",
      "Hebrews",
      "James",
      "1 Peter",
      "2 Peter",
      "1 John",
      "2 John",
      "3 John",
      "Jude",
      "Revelation"
    ];
    return bookNumber > 0 && bookNumber <= books.length ? books[bookNumber - 1] : "Unknown Book";
  }
  /**
   * Fetch Bible book names and abbreviations from JW.org in the specified language
   * This uses multiple strategies to extract data from different parts of the JW.org Bible interface
   * @param language Language code (e.g., 'E' for English, 'T' for Portuguese)
   * @returns A mapping of book names to book numbers
   */
  async fetchLocalizedBookNames(language) {
    try {
      console.log(`Fetching localized book names for language: ${language}`);
      const mainUrl = `https://www.jw.org/finder?wtlocale=${language}&pub=nwtsty`;
      console.log(`Fetching main Bible URL: ${mainUrl}`);
      const response = await (0, import_obsidian.requestUrl)({
        url: mainUrl,
        method: "GET",
        headers: {
          "Accept": "text/html",
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
        }
      });
      const html = response.text;
      const bookNames = {};
      const bookNumberToName = {};
      const standardAbbrevs = {};
      const alternateAbbrevs = {};
      const originalFullNames = {};
      const originalLongAbbrs = {};
      const originalShortAbbrs = {};
      console.log("Looking for Bible books with fullName, longAbbrName and abbrName spans");
      const bookElementPattern = /<a[^>]*?class=[^>]*?bibleBook[^>]*?data-book=['"]([\d]+)['"]\s*[^>]*?>[\s\S]*?<span[^>]*?class=['"]\s*fullName\s*['"]\s*[^>]*?>([^<]+)<\/span>[\s\S]*?<span[^>]*?class=['"]\s*longAbbrName\s*['"]\s*[^>]*?>([^<]+)<\/span>[\s\S]*?<span[^>]*?class=['"]\s*abbrName\s*['"]\s*[^>]*?>([^<]+)<\/span>/gi;
      let match;
      let booksFound = 0;
      while ((match = bookElementPattern.exec(html)) !== null) {
        const bookNumber = parseInt(match[1]);
        const fullName = match[2].trim();
        const longAbbr = match[3].trim();
        const shortAbbr = match[4].trim();
        if (bookNumber > 0 && bookNumber <= 66) {
          booksFound++;
          console.log(`Found book #${bookNumber}: ${fullName} (Long abbr: ${longAbbr}, Short abbr: ${shortAbbr})`);
          originalFullNames[bookNumber] = fullName;
          originalLongAbbrs[bookNumber] = longAbbr;
          originalShortAbbrs[bookNumber] = shortAbbr;
          const normalizedName = fullName.toLowerCase();
          bookNames[normalizedName] = bookNumber;
          bookNumberToName[bookNumber] = fullName;
          standardAbbrevs[bookNumber] = longAbbr;
          const normalizedLongAbbr = longAbbr.toLowerCase();
          if (!bookNames[normalizedLongAbbr]) {
            bookNames[normalizedLongAbbr] = bookNumber;
          }
          alternateAbbrevs[bookNumber] = shortAbbr;
          const normalizedShortAbbr = shortAbbr.toLowerCase();
          if (!bookNames[normalizedShortAbbr]) {
            bookNames[normalizedShortAbbr] = bookNumber;
          }
          this.addBookAbbreviations(bookNames, normalizedName, bookNumber);
        }
      }
      console.log(`Found ${booksFound} books using main pattern.`);
      if (booksFound < 40) {
        console.log("Trying alternate pattern for finding Bible books");
        const altPattern = /<div[^>]*?data-pid=['"]([\d]+)['"]\s*[^>]*?>\s*<div[^>]*?>\s*([^<]+)<\/div>/gi;
        while ((match = altPattern.exec(html)) !== null) {
          const bookId = match[1];
          const bookName = match[2].trim();
          const bookNumber = this.getBookNumberFromHtmlId(bookId);
          if (bookNumber > 0 && bookNumber <= 66) {
            console.log(`Found book with alternate pattern: ${bookName} (${bookNumber})`);
            originalFullNames[bookNumber] = bookName;
            const normalizedName = bookName.toLowerCase();
            bookNames[normalizedName] = bookNumber;
            bookNumberToName[bookNumber] = bookName;
            if (!standardAbbrevs[bookNumber]) {
              const stdAbbrev = this.generateStandardAbbreviation(bookName);
              standardAbbrevs[bookNumber] = stdAbbrev;
              originalLongAbbrs[bookNumber] = stdAbbrev;
              const normalizedStdAbbrev = stdAbbrev.toLowerCase();
              if (!bookNames[normalizedStdAbbrev]) {
                bookNames[normalizedStdAbbrev] = bookNumber;
              }
            }
            if (!alternateAbbrevs[bookNumber]) {
              const altAbbrev = this.generateAlternateAbbreviation(bookName);
              alternateAbbrevs[bookNumber] = altAbbrev;
              originalShortAbbrs[bookNumber] = altAbbrev;
              const normalizedAltAbbrev = altAbbrev.toLowerCase();
              if (!bookNames[normalizedAltAbbrev]) {
                bookNames[normalizedAltAbbrev] = bookNumber;
              }
            }
            this.addBookAbbreviations(bookNames, normalizedName, bookNumber);
          }
        }
      }
      for (let i = 1; i <= 66; i++) {
        if (bookNumberToName[i]) {
          const fullName = bookNumberToName[i];
          if (!standardAbbrevs[i]) {
            let stdAbbrev = this.generateStandardAbbreviation(fullName);
            standardAbbrevs[i] = stdAbbrev;
            originalLongAbbrs[i] = stdAbbrev;
            console.log(`Generated standard abbreviation for book ${i}: ${stdAbbrev}`);
          }
          if (!alternateAbbrevs[i]) {
            let altAbbrev = this.generateAlternateAbbreviation(fullName);
            alternateAbbrevs[i] = altAbbrev;
            originalShortAbbrs[i] = altAbbrev;
            console.log(`Generated alternate abbreviation for book ${i}: ${altAbbrev}`);
          }
        }
      }
      this.standardAbbreviations = standardAbbrevs;
      this.alternateAbbreviations = alternateAbbrevs;
      this.originalFullNames = originalFullNames;
      this.originalLongAbbrs = originalLongAbbrs;
      this.originalShortAbbrs = originalShortAbbrs;
      console.log(`Successfully fetched ${Object.keys(bookNames).length} book names and ${Object.keys(standardAbbrevs).length} abbreviations`);
      return bookNames;
    } catch (error) {
      console.error(`Error fetching localized book names: ${error}`);
      return {};
    }
  }
  /**
   * Get original full name (with proper capitalization) for a book by number
   */
  getOriginalFullName(bookNumber) {
    return this.originalFullNames[bookNumber];
  }
  /**
   * Get original long abbreviation (with proper capitalization) for a book by number
   */
  getOriginalLongAbbr(bookNumber) {
    return this.originalLongAbbrs[bookNumber];
  }
  /**
   * Get original short abbreviation (with proper capitalization) for a book by number
   */
  getOriginalShortAbbr(bookNumber) {
    return this.originalShortAbbrs[bookNumber];
  }
  /**
   * Get book number from HTML ID in JW.org Bible interface
   */
  getBookNumberFromHtmlId(htmlId) {
    const id = parseInt(htmlId);
    if (id >= 1 && id <= 39) {
      return id;
    } else if (id >= 40 && id <= 66) {
      return id;
    } else if (id >= 200 && id <= 226) {
      return id - 200 + 40;
    }
    return 0;
  }
  /**
   * Generate a standard abbreviation (with period) for a book name
   */
  generateStandardAbbreviation(bookName) {
    const numericPrefixMatch = bookName.match(/^(\d+)\s+(.+)$/);
    if (numericPrefixMatch) {
      const prefix = numericPrefixMatch[1];
      const baseName = numericPrefixMatch[2];
      return `${prefix} ${baseName.substring(0, Math.min(3, baseName.length))}.`;
    }
    return `${bookName.substring(0, Math.min(3, bookName.length))}.`;
  }
  /**
   * Generate an alternate abbreviation (without period) for a book name
   */
  generateAlternateAbbreviation(bookName) {
    const numericPrefixMatch = bookName.match(/^(\d+)\s+(.+)$/);
    if (numericPrefixMatch) {
      const prefix = numericPrefixMatch[1];
      const baseName = numericPrefixMatch[2];
      return `${prefix}${baseName.substring(0, Math.min(2, baseName.length))}`;
    }
    return bookName.substring(0, Math.min(2, bookName.length));
  }
  /**
   * Generate common abbreviations for a book name and add them to the book names mapping
   * @param bookNames The book names mapping to add abbreviations to
   * @param fullName The full book name
   * @param bookNumber The book number
   */
  addBookAbbreviations(bookNames, fullName, bookNumber) {
    try {
      const numericPrefixMatch = fullName.match(/^(\d+)\s+(.+)$/);
      let prefix = "";
      let baseName = fullName;
      if (numericPrefixMatch) {
        prefix = numericPrefixMatch[1];
        baseName = numericPrefixMatch[2];
        bookNames[`${prefix}${baseName}`] = bookNumber;
      }
      const shortAbbrev = prefix ? `${prefix} ${baseName.substring(0, 3)}` : baseName.substring(0, 3);
      bookNames[shortAbbrev] = bookNumber;
      if (prefix) {
        bookNames[`${prefix}${baseName.substring(0, 3)}`] = bookNumber;
      }
      if (baseName.length > 3) {
        const veryShortAbbrev = prefix ? `${prefix} ${baseName.substring(0, 2)}` : baseName.substring(0, 2);
        bookNames[veryShortAbbrev] = bookNumber;
        if (prefix) {
          bookNames[`${prefix}${baseName.substring(0, 2)}`] = bookNumber;
        }
      }
    } catch (error) {
      console.error(`Error creating abbreviations for "${fullName}": ${error}`);
    }
  }
  /**
   * Get the standard abbreviation for a book by number
   */
  getStandardAbbreviation(bookNumber) {
    return this.standardAbbreviations[bookNumber];
  }
  /**
   * Get the alternate abbreviation for a book by number
   */
  getAlternateAbbreviation(bookNumber) {
    return this.alternateAbbreviations[bookNumber];
  }
};
var JWPubPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
  }
  // Use definite assignment assertion
  async onload() {
    await this.loadSettings();
    this.bibleService = new BibleService(this.settings);
    this.settingsTab = new JWPubSettingTab(this.app, this);
    this.addSettingTab(this.settingsTab);
    const language = this.settings.language;
    const hasBookNames = this.settings.localizedBookNames && this.settings.localizedBookNames[language] && Object.keys(this.settings.localizedBookNames[language]).length > 0;
    if (!hasBookNames) {
      this.fetchAndSetupBookNames(language).catch((error) => {
        console.error(`Error auto-fetching book names: ${error}`);
      });
    }
    this.addCommand({
      id: "insert-bible-verse",
      name: "Insert Bible Verse",
      editorCallback: (editor, ctx) => {
        if (ctx instanceof import_obsidian.MarkdownView) {
          new BibleReferenceModal(this.app, this, editor).open();
        }
      }
    });
    this.addCommand({
      id: "update-bible-verses",
      name: "Update All Bible Verses",
      editorCallback: (editor, ctx) => {
        this.updateAllVerses(editor);
      }
    });
    this.addCommand({
      id: "convert-bible-references",
      name: "Convert Bible References to Live Verses",
      editorCallback: (editor, ctx) => {
        this.findAndConvertReferences(editor);
      }
    });
    const ribbonIconEl = this.addRibbonIcon("book", "Insert Bible Verse", (evt) => {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (view) {
        new BibleReferenceModal(this.app, this, view.editor).open();
      } else {
        new import_obsidian.Notice("Open a markdown file first");
      }
    });
    this.addRibbonIcon("search", "Find and Convert Bible References", (evt) => {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (view) {
        this.findAndConvertReferences(view.editor);
      } else {
        new import_obsidian.Notice("Open a markdown file first");
      }
    });
    if (this.settings.autoUpdate) {
      this.registerEvent(
        this.app.workspace.on("file-open", () => {
          const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
          if (view) {
            this.updateAllVerses(view.editor);
          }
        })
      );
    }
  }
  /**
   * Helper method to fetch and setup Bible book names for a language
   * This is used for auto-fetching on first load and when changing languages
   */
  async fetchAndSetupBookNames(language) {
    console.log(`Auto-fetching Bible book names for language: ${language}`);
    try {
      const bookNames = await this.bibleService.fetchLocalizedBookNames(language);
      const bookCount = Object.keys(bookNames).length;
      if (bookCount > 0) {
        if (!this.settings.localizedBookNames) {
          this.settings.localizedBookNames = {};
        }
        this.settings.localizedBookNames[language] = bookNames;
        this.settings.lastLanguageUpdate[language] = Date.now();
        for (let i = 1; i <= 66; i++) {
          const bookCode = i.toString().padStart(2, "0");
          const fullName = this.bibleService.getOriginalFullName(i);
          const stdAbbrev = this.bibleService.getOriginalLongAbbr(i);
          const altAbbrev = this.bibleService.getOriginalShortAbbr(i);
          if (fullName) {
            this.settings.customBookNames[bookCode] = fullName;
          }
          if (stdAbbrev) {
            this.settings.standardAbbreviations[bookCode] = stdAbbrev;
          }
          if (altAbbrev) {
            this.settings.alternateAbbreviations[bookCode] = altAbbrev;
          }
        }
        await this.saveSettings();
        console.log(`Auto-fetched ${bookCount} Bible book names for language: ${language}`);
      } else {
        console.warn(`Could not auto-fetch Bible book names for language: ${language}`);
      }
    } catch (error) {
      console.error(`Error auto-fetching Bible book names: ${error}`);
    }
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.bibleService = new BibleService(this.settings);
  }
  /**
   * Insert a Bible verse at the current cursor position
   */
  async insertBibleVerse(editor, reference) {
    try {
      const referenceCode = this.bibleService.parseReference(reference);
      if (!referenceCode) {
        new import_obsidian.Notice(`Invalid Bible reference: ${reference}`);
        return;
      }
      new import_obsidian.Notice(`Fetching verse: ${reference}...`);
      const url = this.bibleService.generateUrl(referenceCode);
      const verse = await this.bibleService.fetchVerse(referenceCode);
      let verseText = "";
      let formattedReference = reference;
      if (verse) {
        verseText = verse.text;
        formattedReference = verse.reference;
      } else {
        verseText = "%% Could not fetch verse content. Click the link to view on jw.org. %%";
        new import_obsidian.Notice(`Could not fetch verse: ${reference}. Creating link only.`);
      }
      const verseBlock = `> [Bible: ${formattedReference}](${url})
> ${verseText}

`;
      try {
        const cursor = editor.getCursor();
        console.log(`Before insertion - Cursor position: Line ${cursor.line}, Ch ${cursor.ch}`);
        if (cursor && cursor.line >= 0) {
          editor.replaceSelection(verseBlock);
          const insertedLines = verseBlock.split("\n").length - 1;
          const newPosition = {
            line: cursor.line + insertedLines,
            ch: 0
          };
          editor.setCursor(newPosition);
          console.log(`After insertion - Set cursor to: Line ${newPosition.line}, Ch ${newPosition.ch}`);
        } else {
          console.log("No valid cursor position, inserting at end of document");
          this.insertVerseAtEnd(editor, verseBlock);
        }
      } catch (error) {
        console.error("Error inserting at cursor position:", error);
        this.insertVerseAtEnd(editor, verseBlock);
      }
      new import_obsidian.Notice(`Inserted: ${formattedReference}`);
    } catch (error) {
      console.error("Error inserting Bible verse:", error);
      new import_obsidian.Notice(`Error inserting Bible verse: ${error.message || String(error)}`);
    }
  }
  /**
   * Insert a Bible verse as a link with verse content below
   */
  async insertBibleVerseAsLink(editor, reference) {
    try {
      const referenceCode = this.bibleService.parseReference(reference);
      if (!referenceCode) {
        new import_obsidian.Notice(`Invalid Bible reference: ${reference}`);
        return;
      }
      new import_obsidian.Notice(`Fetching verse: ${reference}...`);
      const url = this.bibleService.generateUrl(referenceCode);
      const verse = await this.bibleService.fetchVerse(referenceCode);
      let verseText = "";
      let formattedReference = reference;
      if (verse) {
        verseText = verse.text;
        formattedReference = verse.reference;
      } else {
        verseText = "%% Could not fetch verse content. Click the link to view on jw.org. %%";
        new import_obsidian.Notice(`Could not fetch verse: ${reference}. Creating link only.`);
      }
      let verseBlock = "";
      const linkPart = `${this.settings.linkPrefix}[${formattedReference}](${url})${this.settings.linkSuffix}`;
      if (this.settings.insertLinkOnly) {
        verseBlock = `${linkPart}

`;
      } else {
        verseBlock = verseText.includes("%%") ? `${linkPart}

${verseText}

` : `${linkPart}

${this.settings.versePrefix}${verseText}${this.settings.verseSuffix}

`;
      }
      try {
        const cursor = editor.getCursor();
        console.log(`Before insertion - Cursor position: Line ${cursor.line}, Ch ${cursor.ch}`);
        if (cursor && cursor.line >= 0) {
          editor.replaceSelection(verseBlock);
          const insertedLines = verseBlock.split("\n").length - 1;
          const newPosition = {
            line: cursor.line + insertedLines,
            ch: 0
          };
          editor.setCursor(newPosition);
          console.log(`After insertion - Set cursor to: Line ${newPosition.line}, Ch ${newPosition.ch}`);
        } else {
          console.log("No valid cursor position, inserting at end of document");
          this.insertVerseAtEnd(editor, verseBlock);
        }
      } catch (error) {
        console.error("Error inserting at cursor position:", error);
        this.insertVerseAtEnd(editor, verseBlock);
      }
      new import_obsidian.Notice(`Inserted: ${formattedReference}`);
    } catch (error) {
      console.error("Error inserting Bible verse:", error);
      new import_obsidian.Notice(`Error inserting Bible verse: ${error.message || String(error)}`);
    }
  }
  /**
   * Helper method to insert verse text at the end of the document
   */
  insertVerseAtEnd(editor, verseBlock) {
    try {
      const docLength = editor.lineCount();
      const endPosition = {
        line: docLength,
        ch: 0
      };
      editor.replaceRange(verseBlock, endPosition);
      const newPosition = {
        line: docLength + verseBlock.split("\n").length - 1,
        ch: 0
      };
      editor.setCursor(newPosition);
      console.log(`Inserted at end - Set cursor to: Line ${newPosition.line}, Ch ${newPosition.ch}`);
    } catch (error) {
      console.error("Error inserting at end of document:", error);
    }
  }
  /**
   * Update all Bible verses in the current note
   */
  async updateAllVerses(editor) {
    const content = editor.getValue();
    let updatedCount = 0;
    let failedCount = 0;
    let content2 = content;
    const blockquoteRegex = /> \[Bible: (.*?)\]\((https:\/\/www\.jw\.org\/finder\?wtlocale=.*?&bible=.*?)\)\n> (.*?)(?:\n> \*Last updated: (.*?)\*)?/g;
    const blockquoteMatches = [];
    let match;
    while ((match = blockquoteRegex.exec(content)) !== null) {
      blockquoteMatches.push({
        fullMatch: match[0],
        reference: match[1],
        url: match[2],
        text: match[3],
        lastUpdated: match[4],
        // This may be undefined if there's no timestamp
        index: match.index,
        length: match[0].length,
        format: "blockquote"
      });
    }
    const linkRegex = /\[(.*?)\]\((https:\/\/www\.jw\.org\/finder\?wtlocale=.*?&bible=.*?)\)\s*\n\s*(?:"(.*?)"|([^*\n]+))(?:\s*\n\s*\*Last updated: (.*?)\*)?/g;
    const linkMatches = [];
    while ((match = linkRegex.exec(content)) !== null) {
      linkMatches.push({
        fullMatch: match[0],
        reference: match[1],
        url: match[2],
        text: match[3] || match[4],
        // Either quoted text or unquoted text
        lastUpdated: match[5],
        // This may be undefined
        index: match.index,
        length: match[0].length,
        format: "link"
      });
    }
    const allMatches = [...blockquoteMatches, ...linkMatches];
    allMatches.sort((a, b) => b.index - a.index);
    for (const match2 of allMatches) {
      const urlRegex = /bible=(\d+)/;
      const urlMatch = match2.url.match(urlRegex);
      if (!urlMatch)
        continue;
      const referenceCode = urlMatch[1];
      let shouldUpdate = true;
      if (match2.lastUpdated) {
        const lastUpdatedDate = new Date(match2.lastUpdated);
        const now = /* @__PURE__ */ new Date();
        const daysSinceUpdate = (now.getTime() - lastUpdatedDate.getTime()) / (1e3 * 3600 * 24);
        shouldUpdate = daysSinceUpdate >= this.settings.updateInterval;
      }
      if (!shouldUpdate) {
        continue;
      }
      const verse = await this.bibleService.fetchVerse(referenceCode);
      const url = this.bibleService.generateUrl(referenceCode);
      let updatedVerseBlock;
      let referenceText = match2.reference;
      let verseText = match2.text;
      if (verse) {
        referenceText = verse.reference;
        verseText = verse.text;
        updatedCount++;
      } else {
        failedCount++;
      }
      const linkPart = `${this.settings.linkPrefix}[${referenceText}](${url})${this.settings.linkSuffix}`;
      if (match2.format === "blockquote") {
        updatedVerseBlock = `> [Bible: ${referenceText}](${url})
> ${verseText}`;
      } else {
        if (this.settings.insertLinkOnly) {
          updatedVerseBlock = `${linkPart}`;
        } else {
          updatedVerseBlock = verseText.includes("%%") ? `${linkPart}

${verseText}` : `${linkPart}

${this.settings.versePrefix}${verseText}${this.settings.verseSuffix}`;
        }
      }
      content2 = content2.substring(0, match2.index) + updatedVerseBlock + content2.substring(match2.index + match2.length);
    }
    if (updatedCount > 0 || failedCount > 0) {
      editor.setValue(content2);
      let message = `Updated ${updatedCount + failedCount} Bible verses.`;
      if (failedCount > 0) {
        message += ` (${failedCount} couldn't fetch new content)`;
      }
      new import_obsidian.Notice(message);
    }
  }
  /**
   * Find all Bible references in the text and convert them to live verses
   */
  async findAndConvertReferences(editor) {
    const content = editor.getValue();
    const liveVerseRegex = /(\> \[Bible: .*?\]\(https:\/\/www\.jw\.org\/finder\?.*?\)|(\[.*?\]\(https:\/\/www\.jw\.org\/finder\?.*?\))(?:\s*\n\s*(?:\".*?\"|(?:[^*\n]+))))/g;
    const liveVerses = [];
    let liveMatch;
    while ((liveMatch = liveVerseRegex.exec(content)) !== null) {
      liveVerses.push({
        start: liveMatch.index,
        end: liveMatch.index + liveMatch[0].length
      });
    }
    console.log(`Found ${liveVerses.length} already converted live verses to avoid duplicating.`);
    const referenceRegex = /\b((?:\d\s*)?[\p{L}]+\.?)\s+(\d+):(\d+)(?:[-,]\d+)?\b/gu;
    const references = [];
    let match;
    while ((match = referenceRegex.exec(content)) !== null) {
      const isAlreadyConverted = liveVerses.some(
        (liveVerse) => match !== null && match.index >= liveVerse.start && match.index + match[0].length <= liveVerse.end
      );
      if (!isAlreadyConverted) {
        references.push({
          text: match[0],
          index: match.index,
          length: match[0].length
        });
      }
    }
    if (references.length === 0) {
      new import_obsidian.Notice("No new Bible references found to convert");
      return;
    }
    const modal = new ConfirmModal(
      this.app,
      `Found ${references.length} new Bible references. Convert them to live verses?`,
      async (confirmed) => {
        if (confirmed) {
          await this.convertReferences(editor, references);
        }
      }
    );
    modal.open();
  }
  /**
   * Convert Bible references to live verses
   */
  async convertReferences(editor, references) {
    references.sort((a, b) => b.index - a.index);
    let content = editor.getValue();
    let successCount = 0;
    let failCount = 0;
    let partialCount = 0;
    new import_obsidian.Notice(`Converting ${references.length} Bible references to live verses...`);
    for (const ref of references) {
      const referenceCode = this.bibleService.parseReference(ref.text);
      if (!referenceCode) {
        failCount++;
        continue;
      }
      const url = this.bibleService.generateUrl(referenceCode);
      const verse = await this.bibleService.fetchVerse(referenceCode);
      let verseText = "";
      let formattedReference = ref.text;
      if (verse) {
        verseText = verse.text;
        formattedReference = verse.reference;
        successCount++;
      } else {
        verseText = "%% Could not fetch verse content. Click the link to view on jw.org. %%";
        partialCount++;
      }
      let verseBlock = "";
      const linkPart = `${this.settings.linkPrefix}[${formattedReference}](${url})${this.settings.linkSuffix}`;
      if (this.settings.insertLinkOnly) {
        verseBlock = `${linkPart}

`;
      } else {
        verseBlock = verseText.includes("%%") ? `${linkPart}

${verseText}

` : `${linkPart}

${this.settings.versePrefix}${verseText}${this.settings.verseSuffix}

`;
      }
      content = content.substring(0, ref.index) + verseBlock + content.substring(ref.index + ref.length);
    }
    editor.setValue(content);
    if (successCount > 0 || partialCount > 0) {
      let message = `Converted ${successCount + partialCount} Bible references to live verses.`;
      if (successCount > 0 && partialCount > 0) {
        message += ` (${successCount} with content, ${partialCount} with links only)`;
      } else if (partialCount > 0) {
        message += ` (content could not be fetched, links only)`;
      }
      if (failCount > 0) {
        message += ` (${failCount} failed completely)`;
      }
      new import_obsidian.Notice(message);
    } else if (failCount > 0) {
      new import_obsidian.Notice(`Failed to convert ${failCount} Bible references.`);
    }
  }
};
var JWPubSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "JW Bible Verses Plugin Settings" });
    const languageContainer = containerEl.createEl("div", { cls: "language-setting-container" });
    languageContainer.createEl("h3", { text: "Language Settings" });
    const languageSetting = new import_obsidian.Setting(languageContainer).setName("Language Code").setDesc("Set the language code for Bible verses. Use the instructions below to find your preferred language code.").addText((text) => text.setPlaceholder("E").setValue(this.plugin.settings.language).onChange(async (value) => {
      let language = value.trim();
      const wtlocaleMatch = language.match(/wtlocale=([A-Za-z0-9_-]+)/i);
      if (wtlocaleMatch) {
        language = wtlocaleMatch[1];
      }
      if (language && language.length >= 1 && language.length <= 10) {
        const oldLanguage = this.plugin.settings.language;
        if (language !== oldLanguage) {
          this.plugin.settings.language = language;
          await this.plugin.saveSettings();
          try {
            new import_obsidian.Notice(`Language changed to ${language}. Fetching Bible book names...`);
            await this.plugin.fetchAndSetupBookNames(language);
            this.display();
          } catch (error) {
            console.error(`Error fetching book names for new language: ${error}`);
          }
        }
      }
    }));
    const instructionsContainer = languageContainer.createEl("details", { cls: "language-instructions" });
    instructionsContainer.createEl("summary", { text: "How to find your language code" });
    const instructionsList = instructionsContainer.createEl("ol", { cls: "instructions-list" });
    instructionsList.createEl("li", {
      text: "Click this link to open Matthew 1:1 in English on JW.org:"
    }).appendChild(
      createEl("a", {
        text: "Matthew 1:1 (English)",
        href: "https://www.jw.org/finder?pub=nwtsty&bible=40001000&wtlocale=E",
        attr: { target: "_blank" }
      })
    );
    instructionsList.createEl("li", {
      text: "On the JW.org website, change the language to your desired language (e.g., Portuguese, Spanish, etc.)."
    });
    instructionsList.createEl("li", {
      text: 'Scroll down to the end of the chapter and click the "Share" button.'
    });
    instructionsList.createEl("li", {
      text: "Copy the link provided in the share dialog."
    });
    instructionsList.createEl("li", {
      text: "Paste the copied link into the Language Code field above. The plugin will automatically extract your language code."
    });
    instructionsList.createEl("li", {
      text: 'The language code will be extracted and saved (e.g., "T" for Portuguese, "S" for Spanish).'
    });
    const exampleContainer = instructionsContainer.createEl("div", { cls: "example-container" });
    exampleContainer.createEl("p", {
      text: 'Example: In a link like "https://www.jw.org/finder?pub=nwtsty&bible=40001000&wtlocale=T&srcid=share", the language code is "T".'
    });
    const styleElement = document.createElement("style");
    styleElement.textContent = `
      .language-setting-container {
        margin-bottom: 24px;
        border: 1px solid var(--background-modifier-border);
        padding: 16px;
        border-radius: 4px;
      }
      .language-setting-container h3 {
        margin-top: 0;
      }
      .language-instructions {
        margin-top: 12px;
        padding: 8px;
        background-color: var(--background-secondary);
        border-radius: 4px;
      }
      .language-instructions summary {
        cursor: pointer;
        font-weight: bold;
        margin-bottom: 8px;
      }
      .instructions-list li {
        margin-bottom: 8px;
      }
      .example-container {
        margin-top: 12px;
        padding: 8px;
        background-color: var(--background-modifier-form-field);
        border-radius: 4px;
        font-family: monospace;
      }
    `;
    languageContainer.appendChild(styleElement);
    if (this.plugin.settings.localizedBookNames && this.plugin.settings.localizedBookNames[this.plugin.settings.language]) {
      const language = this.plugin.settings.language;
      const lastUpdate = this.plugin.settings.lastLanguageUpdate[language];
      const bookNames = this.plugin.settings.localizedBookNames[language];
      const bookCount = Object.keys(bookNames).length;
      const infoEl = containerEl.createEl("div", { cls: "localized-books-info" });
      infoEl.createEl("p", {
        text: `${bookCount} book names available for language code "${language}".`
      });
      if (lastUpdate) {
        infoEl.createEl("p", {
          text: `Last updated: ${new Date(lastUpdate).toLocaleString()}`
        });
      }
      const sampleEl = infoEl.createEl("details");
      sampleEl.createEl("summary", { text: "Sample of available book names" });
      const sampleList = sampleEl.createEl("ul");
      const bookEntries = Object.entries(bookNames);
      const samples = bookEntries.filter(([name]) => name.length > 2 && !name.includes(" ")).slice(0, 10);
      samples.forEach(([name, number]) => {
        sampleList.createEl("li", {
          text: `${name} \u2192 Book ${number}`
        });
      });
    }
    new import_obsidian.Setting(containerEl).setName("Insert Link Only").setDesc("When enabled, only inserts the link without the verse content. When disabled, includes both link and verse text.").addToggle((toggle) => toggle.setValue(this.plugin.settings.insertLinkOnly).onChange(async (value) => {
      this.plugin.settings.insertLinkOnly = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Format Customization" });
    const linkPrefixSetting = new import_obsidian.Setting(containerEl).setName("Link Prefix").setDesc("Text to insert before the link (default: blank)").addText((text) => text.setPlaceholder("").setValue(this.plugin.settings.linkPrefix).onChange(async (value) => {
      this.plugin.settings.linkPrefix = value;
      await this.plugin.saveSettings();
    }));
    linkPrefixSetting.addButton((button) => button.setButtonText("Reset").setTooltip("Reset to default (blank)").onClick(async () => {
      this.plugin.settings.linkPrefix = "";
      await this.plugin.saveSettings();
      this.display();
    }));
    const linkSuffixSetting = new import_obsidian.Setting(containerEl).setName("Link Suffix").setDesc("Text to insert after the link (default: blank)").addText((text) => text.setPlaceholder("").setValue(this.plugin.settings.linkSuffix).onChange(async (value) => {
      this.plugin.settings.linkSuffix = value;
      await this.plugin.saveSettings();
    }));
    linkSuffixSetting.addButton((button) => button.setButtonText("Reset").setTooltip("Reset to default (blank)").onClick(async () => {
      this.plugin.settings.linkSuffix = "";
      await this.plugin.saveSettings();
      this.display();
    }));
    const versePrefixSetting = new import_obsidian.Setting(containerEl).setName("Verse Prefix").setDesc('Text to insert before the verse content (default: "")').addText((text) => text.setPlaceholder("").setValue(this.plugin.settings.versePrefix).onChange(async (value) => {
      this.plugin.settings.versePrefix = value;
      await this.plugin.saveSettings();
    }));
    versePrefixSetting.addButton((button) => button.setButtonText("Reset").setTooltip('Reset to default ("').onClick(async () => {
      this.plugin.settings.versePrefix = "";
      await this.plugin.saveSettings();
      this.display();
    }));
    const verseSuffixSetting = new import_obsidian.Setting(containerEl).setName("Verse Suffix").setDesc('Text to insert after the verse content (default: "")').addText((text) => text.setPlaceholder("").setValue(this.plugin.settings.verseSuffix).onChange(async (value) => {
      this.plugin.settings.verseSuffix = value;
      await this.plugin.saveSettings();
    }));
    verseSuffixSetting.addButton((button) => button.setButtonText("Reset").setTooltip('Reset to default ("').onClick(async () => {
      this.plugin.settings.verseSuffix = "";
      await this.plugin.saveSettings();
      this.display();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto Update").setDesc("Automatically update Bible verses when opening notes").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoUpdate).onChange(async (value) => {
      this.plugin.settings.autoUpdate = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Update Interval").setDesc("Interval in days to check for updates to verses (if Auto Update is enabled)").addSlider((slider) => slider.setLimits(1, 90, 1).setValue(this.plugin.settings.updateInterval).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.updateInterval = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Bible Books Settings" });
    const booksContainer = containerEl.createEl("div", { cls: "books-settings-container" });
    booksContainer.createEl("p", {
      text: "Customize bible book names and abbreviations used for lookup and display. Use the Fetch Book Names button above to populate with names from your selected language. Abbreviations are used for recognition of references in your notes."
    });
    const controlsContainer = booksContainer.createEl("div", { cls: "books-controls" });
    const expandAllButton = createEl("button", { text: "Expand All", cls: "expand-all-button" });
    const collapseAllButton = createEl("button", { text: "Collapse All", cls: "collapse-all-button" });
    const resetAllButton = createEl("button", { text: "Reset Book Names", cls: "reset-all-button" });
    controlsContainer.appendChild(expandAllButton);
    controlsContainer.appendChild(collapseAllButton);
    controlsContainer.appendChild(resetAllButton);
    resetAllButton.addEventListener("click", async () => {
      const language = this.plugin.settings.language;
      if (!confirm(`This will reset all book names and abbreviations to JW.org defaults for language ${language}. Continue?`)) {
        return;
      }
      new import_obsidian.Notice(`Resetting all book names and abbreviations to JW.org defaults...`);
      try {
        await this.plugin.bibleService.fetchLocalizedBookNames(language);
        for (let i = 1; i <= 66; i++) {
          const bookCode = i.toString().padStart(2, "0");
          const fullName = this.plugin.bibleService.getOriginalFullName(i);
          const stdAbbrev = this.plugin.bibleService.getOriginalLongAbbr(i);
          const altAbbrev = this.plugin.bibleService.getOriginalShortAbbr(i);
          if (fullName) {
            this.plugin.settings.customBookNames[bookCode] = fullName;
          }
          if (stdAbbrev) {
            this.plugin.settings.standardAbbreviations[bookCode] = stdAbbrev;
          }
          if (altAbbrev) {
            this.plugin.settings.alternateAbbreviations[bookCode] = altAbbrev;
          }
        }
        await this.plugin.saveSettings();
        this.display();
        new import_obsidian.Notice(`Successfully reset all book names and abbreviations to JW.org defaults`);
      } catch (error) {
        console.error(`Error resetting book names: ${error}`);
        new import_obsidian.Notice(`Error resetting book names and abbreviations: ${error}`);
      }
    });
    for (let i = 1; i <= 66; i++) {
      const bookCode = i.toString().padStart(2, "0");
      const defaultName = this.plugin.bibleService.getBookNameFromCode(bookCode);
      const customName = this.plugin.settings.customBookNames[bookCode] || defaultName;
      const standardAbbrev = this.plugin.settings.standardAbbreviations[bookCode] || (customName.length > 3 ? customName.substring(0, 3) + "." : customName);
      const alternateAbbrev = this.plugin.settings.alternateAbbreviations[bookCode] || (customName.length > 2 ? customName.substring(0, 2) : customName);
      const bookDetails = booksContainer.createEl("details", { cls: "book-details" });
      const bookSummary = bookDetails.createEl("summary", {
        text: `${i}. ${customName}`,
        cls: "book-summary"
      });
      const bookForm = bookDetails.createEl("div", { cls: "book-form" });
      const nameContainer = bookForm.createEl("div", { cls: "form-row" });
      nameContainer.createEl("label", { text: "Book Name:", cls: "form-label" });
      const nameInput = nameContainer.createEl("input", {
        cls: "form-input",
        attr: {
          type: "text",
          value: customName,
          placeholder: defaultName
        }
      });
      const stdAbbrevContainer = bookForm.createEl("div", { cls: "form-row" });
      stdAbbrevContainer.createEl("label", { text: "Standard Abbreviation:", cls: "form-label" });
      const stdAbbrevInput = stdAbbrevContainer.createEl("input", {
        cls: "form-input",
        attr: {
          type: "text",
          value: standardAbbrev,
          placeholder: "e.g. Gen."
        }
      });
      const altAbbrevContainer = bookForm.createEl("div", { cls: "form-row" });
      altAbbrevContainer.createEl("label", { text: "Alternate Abbreviation:", cls: "form-label" });
      const altAbbrevInput = altAbbrevContainer.createEl("input", {
        cls: "form-input",
        attr: {
          type: "text",
          value: alternateAbbrev,
          placeholder: "e.g. Ge"
        }
      });
      const saveContainer = bookForm.createEl("div", { cls: "form-row buttons-row" });
      const saveButton = saveContainer.createEl("button", {
        text: "Save Changes",
        cls: "save-button"
      });
      nameInput.addEventListener("input", () => {
        bookSummary.textContent = `${i}. ${nameInput.value || defaultName}`;
      });
      saveButton.addEventListener("click", async () => {
        this.plugin.settings.customBookNames[bookCode] = nameInput.value;
        this.plugin.settings.standardAbbreviations[bookCode] = stdAbbrevInput.value;
        this.plugin.settings.alternateAbbreviations[bookCode] = altAbbrevInput.value;
        await this.plugin.saveSettings();
        new import_obsidian.Notice(`Saved settings for ${nameInput.value}`);
      });
    }
    expandAllButton.addEventListener("click", () => {
      booksContainer.querySelectorAll("details").forEach((detail) => {
        detail.setAttribute("open", "");
      });
    });
    collapseAllButton.addEventListener("click", () => {
      booksContainer.querySelectorAll("details").forEach((detail) => {
        detail.removeAttribute("open");
      });
    });
    const style = document.createElement("style");
    style.textContent = `
      .books-settings-container {
        margin-top: 12px;
        padding: 8px;
        border: 1px solid var(--background-modifier-border);
        border-radius: 4px;
      }
      
      .books-controls {
        display: flex;
        gap: 8px;
        margin-bottom: 16px;
      }
      
      .expand-all-button, .collapse-all-button, .reset-all-button {
        padding: 4px 8px;
        border-radius: 4px;
        border: 1px solid var(--background-modifier-border);
        background-color: var(--interactive-normal);
        cursor: pointer;
      }
      
      .expand-all-button:hover, .collapse-all-button:hover, .reset-all-button:hover {
        background-color: var(--interactive-hover);
      }
      
      .reset-all-button {
        margin-left: auto;
        background-color: var(--text-error);
        color: var(--text-on-accent);
      }
      
      .book-details {
        margin-bottom: 8px;
        border: 1px solid var(--background-modifier-border);
        border-radius: 4px;
        overflow: hidden;
      }
      
      .book-summary {
        padding: 8px;
        cursor: pointer;
        background-color: var(--background-secondary);
      }
      
      .book-summary:hover {
        background-color: var(--background-modifier-hover);
      }
      
      .book-form {
        padding: 12px;
      }
      
      .form-row {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
      }
      
      .form-label {
        flex: 0 0 150px;
        margin-right: 8px;
      }
      
      .form-input {
        flex: 1;
        padding: 4px 8px;
        border-radius: 4px;
        border: 1px solid var(--background-modifier-border);
      }
      
      .buttons-row {
        justify-content: flex-end;
        margin-top: 16px;
      }
      
      .save-button {
        padding: 6px 12px;
        border-radius: 4px;
        border: 1px solid var(--background-modifier-border);
        background-color: var(--interactive-accent);
        color: var(--text-on-accent);
        cursor: pointer;
      }
      
      .save-button:hover {
        background-color: var(--interactive-accent-hover);
      }
    `;
    containerEl.appendChild(style);
  }
};
var BibleReferenceModal = class extends import_obsidian.Modal {
  // Use definite assignment assertion
  constructor(app, plugin, editor) {
    super(app);
    this.plugin = plugin;
    this.editor = editor;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Insert Bible Verse" });
    const exampleText = this.createExampleText();
    contentEl.createEl("p", { text: exampleText });
    this.referenceInput = contentEl.createEl("input", {
      type: "text",
      placeholder: "Bible reference"
    });
    const linkOnlyContainer = contentEl.createEl("div", {
      cls: "link-only-container"
    });
    linkOnlyContainer.createEl("label", { text: "Insert link only (no verse content)" });
    const linkOnlyCheckbox = linkOnlyContainer.createEl("input", {
      type: "checkbox"
    });
    linkOnlyCheckbox.checked = this.plugin.settings.insertLinkOnly;
    this.referenceInput.focus();
    this.referenceInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        const reference = this.referenceInput.value.trim();
        if (reference) {
          if (this.plugin.settings.insertLinkOnly !== linkOnlyCheckbox.checked) {
            this.plugin.settings.insertLinkOnly = linkOnlyCheckbox.checked;
            this.plugin.saveSettings();
          }
          this.plugin.insertBibleVerseAsLink(this.editor, reference);
          this.close();
        }
      }
    });
    const buttonContainer = contentEl.createEl("div", {
      cls: "modal-button-container"
    });
    const submitButton = buttonContainer.createEl("button", {
      text: "Insert",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => {
      const reference = this.referenceInput.value.trim();
      if (reference) {
        if (this.plugin.settings.insertLinkOnly !== linkOnlyCheckbox.checked) {
          this.plugin.settings.insertLinkOnly = linkOnlyCheckbox.checked;
          this.plugin.saveSettings();
        }
        this.plugin.insertBibleVerseAsLink(this.editor, reference);
        this.close();
      }
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }
  /**
   * Create example text for Bible references using the current language configuration
   */
  createExampleText() {
    let johnName = "John";
    let johnAbbrevStd = "John";
    let johnAbbrevAlt = "Jn";
    let matthewName = "Matthew";
    let matthewAbbrevStd = "Matt.";
    let matthewAbbrevAlt = "Mt";
    try {
      const johnCode = "43";
      if (this.plugin.settings.customBookNames[johnCode]) {
        johnName = this.plugin.settings.customBookNames[johnCode];
      }
      if (this.plugin.settings.standardAbbreviations[johnCode]) {
        johnAbbrevStd = this.plugin.settings.standardAbbreviations[johnCode];
      }
      if (this.plugin.settings.alternateAbbreviations[johnCode]) {
        johnAbbrevAlt = this.plugin.settings.alternateAbbreviations[johnCode];
      }
      const matthewCode = "40";
      if (this.plugin.settings.customBookNames[matthewCode]) {
        matthewName = this.plugin.settings.customBookNames[matthewCode];
      }
      if (this.plugin.settings.standardAbbreviations[matthewCode]) {
        matthewAbbrevStd = this.plugin.settings.standardAbbreviations[matthewCode];
      }
      if (this.plugin.settings.alternateAbbreviations[matthewCode]) {
        matthewAbbrevAlt = this.plugin.settings.alternateAbbreviations[matthewCode];
      }
    } catch (error) {
      console.error("Error getting localized book examples:", error);
    }
    return `Enter a Bible reference using full names or abbreviations:
\u2022 Full name: "${johnName} 3:16" or "${matthewName} 1:1"
\u2022 Standard abbreviation: "${johnAbbrevStd} 3:16" or "${matthewAbbrevStd} 1:1"
\u2022 Short abbreviation: "${johnAbbrevAlt} 3:16" or "${matthewAbbrevAlt} 1:1"`;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ConfirmModal = class extends import_obsidian.Modal {
  constructor(app, message, callback) {
    super(app);
    this.message = message;
    this.callback = callback;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Confirm Action" });
    contentEl.createEl("p", { text: this.message });
    const buttonContainer = contentEl.createEl("div", {
      cls: "modal-button-container"
    });
    const confirmButton = buttonContainer.createEl("button", {
      text: "Yes",
      cls: "mod-cta"
    });
    confirmButton.addEventListener("click", () => {
      this.callback(true);
      this.close();
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "No"
    });
    cancelButton.addEventListener("click", () => {
      this.callback(false);
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
